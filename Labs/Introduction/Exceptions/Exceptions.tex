\lab{Exceptions and File I/O}{Exceptions and File I/O Protocol}
\label{lab:Exceptions}
\objective{
In Python, an \emph{exception} is an error detected during execution.
Exceptions are important for regulating program usage and correctly informing the programmer of problems.
Understanding exceptions allows us to safely read data from and export data to external files.
Reading and parsing data is an essential skill in scientific computing, and will be an important element of many future labs.
}

% TODO
%       - print statments --> print function calls in Python 3 (parentheses)
%       - String Formatting section. ALMOST THERE!!!!
%       - Additional material section?

\section*{Exceptions} % =======================================================

Every programming language has a formal way of indicating and handling errors.
In Python, we raise and handle \emph{exceptions}.
There are different kinds of exceptions, each with its appropriate usage.

\begin{lstlisting}
# A 'NameError' exception indicates that a nonexistant name was used.
>>> print(x)
<<Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined>>

# An 'AttributeError' exception indicates that a nonexistant method
# or attribute was called on some object.
>>> [1, 2, 3].fly()
<<Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'list' object has no attribute 'fly'>>

# A 'SyntaxError' exception indicates bad Python syntax.
>>> def myFunction(a, b)             # Forgot the colon!
<<  File "<stdin>", line 1
    def myFunction(a, b)
                       ^
SyntaxError: invalid syntax>>
\end{lstlisting}

See \url{https://docs.python.org/2/library/exceptions.html} for the complete list of Python's built-in exception classes.

\subsection*{Raising Exceptions} % --------------------------------------------

Many exceptions, like the ones demonstrated above, are due to coding mistakes and typos.
Exceptions can also be used intentionally to indicate a problem to the user or programmer.
To create an exception, use the keyword \li{raise}, followed by the name of the exception class.
As soon as an exception is raised, the program stops running unless the exception is handled properly.

Exception objects can be initialized with any number of arguments.
These arguments are stored as a tuple attribute called \li{args}, which serves as the string representation of the object.
We typically provide a single string detailing the reasons for the error.

\begin{lstlisting}
# Raise a generic exception, without an error message.
>>> if 7 is not 7.0:
...     raise Exception
... 
<<Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
Exception>>

# Now raise a more specific exception, with an error message included.
>>> for x in range(10):
...     if x > 5:
...         raise ValueError("'x' should not exceed 5.")
...     print(x),
... 
0 1 2 3 4 5
<<Traceback (most recent call last):
  File "<stdin>", line 3, in <module>
ValueError: 'x' should not exceed 5.>>
\end{lstlisting}

% TODO: Make this much more interesting.
\begin{problem} % Raising Exceptions 101.
Python functions do not require specific types of data for each functional input.
Sometimes, however, it is important to validate input types before they are utilized. TODO: Make \li{my_func()} waaay more interesting.
\begin{lstlisting}
def my_func(a, b, c, d, e):
    print("The first argument is " + a)
    x = sum([b, c])
    y = d + e
    return a, x, y
\end{lstlisting}
Modify \li{my_func()} so that it raises a \li{TypeError} if:
\begin{enumerate}
\item $a$ is not a string (of type \li{str}),
\item $b$ or $c$ is not a numerical type (\li{int}, \li{float}, \li{long}, or \li{complex}), or
\item $d$ and $e$ are not the same type.
\end{enumerate}
Include an informative error message with each exception.
\\
(Hint: investigate the \li{type()} and \li{isinstance()} built-in functions.)
\end{problem}

\subsection*{Handling Exceptions} % -------------------------------------------

To prevent an exception from stopping the program, it must be handled by
placing the problematic lines of code in a \li{try} block.
An \li{except} block then follows.

\begin{lstlisting}
# The 'try' block should hold any lines of code that might raise an exception.
>>> try:
...     raise Exception("for no reason.")
...     print "No exception raised"
... # The 'except' block is executed when an exception is raised.
... except Exception as e:
...     print "Exception raised", e
... # The program then continues as usual.
... print "Good for you."
... 
<<Exception raised for no reason.
Good for you.>>
\end{lstlisting}
%
The try statement induces a control flow that proceeds as follows:
\begin{description}
\item The \li{try} block is executed until an exception is raised.
\item An \li{except} statement specifying the \emph{same kind} of exception that was raised in the try block ``catches'' the exception, and the block is then executed.
There may be multiple except blocks following a single try block (similiar to having several \li{elif} statements following a single \li{if} statement), and a single except statement may specify multiple kinds of exceptions to catch.
\item The optional \li{else} block is executed if an exception was \emph{not} raised in the try block.
% Thus either an except block or the else block are executed, but not both.
\item Lastly, the optional \li{finally} block is always executed if it is included.
\end{description}

\begin{lstlisting}
>>> try:
...     raise ValueError("The house is on fire!")
... # Check for multiple kinds of exceptions using parentheses.
... except (ValueError, TypeError) as e:
...     house_on_fire = True
... else:                           # Skipped due to the exception.
...     house_on_fire = False
... finally:
...     print "The house is on fire:", house_on_fire
...
<<The house is on fire: True>>

>>> try:
...     house_on_fire = False
... except Exception as e:
...     house_on_fire = True
... else:                           # Executed because there was no exception.
...     print "The house is probably okay."
... finally:
...     print "The house is on fire:", house_on_fire
...
<<The house is probably okay.
The house is on fire: False>>
\end{lstlisting}

The code in the \li{finally} block is \emph{always} executed, even if a \li{return} statement or an uncaught exception occurs in any block following the try statement.

\begin{lstlisting}
>>> try:
...     raise ValueError("The house is on fire!")
... finally:                        # Executes before the error is reported.
...     print "The house may be on fire."
... 
<<The house may be on fire.
Traceback (most recent call last):
  File "<stdin>", line 3, in <module>
ValueError: The house is on fire!>>
\end{lstlisting}

\begin{comment} % Additional material ?
\begin{warn} % Don't use except: by itself; specify an exception class.
Having \li{except} by itself will catch \emph{any} exception raised in the \li{try} block, but this approach can mistakenly mask unexpected errors.
Consider the following function, which intends to avoid dividing by zero.

\begin{lstlisting}
>>> def divider(x, y):
...     try:
...         return x / float(yy)
...     except:
...         print("y must not equal zero!")
... 
>>> divider(2, 3)
<<y must not equal zero!>>
\end{lstlisting}

Because \li{y} was misspelled, a \li{NameError} will be raised every time this function is called.
Be specific about the kind of exception you expect to encounter.

\begin{lstlisting}
>>> def divider(x, y):
...     try:
...         return x / float(yy)
...     except ZeroDivisionError:
...         print("y must not equal zero!")
... 
>>> divider(2, 3)
<<Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in divider
NameError: global name 'yy' is not defined>>
\end{lstlisting}
\end{warn}
\end{comment}

\begin{comment} % Overkill
An exception that is caught by an \li{except} statement can be captured as a variable within the \li{except} block if it is declared using the keyword \li{as}.

\begin{lstlisting}
# Catch only a specific class of exceptions.
>>> try:
...     bad = 100 / 0
... except ZeroDivisionError as e:
...     print(e)
... 
<<integer division or modulo by zero>>

# Here a different exception is raised than the one in the except statement.
>>> try:
...     1 + 'a' + 2 + 'b' + 3
... except ValueError as e:
...     print(e)
<<Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'>>

>>> try:
...     import magic
... except ImportError as e:
...     print "Sorry!", e
... 
Sorry! No module named magic
\end{lstlisting}

Multiple kinds of exceptions can be caught by a single \li{except} statement using a parenthesized list of exceptions.
There can also be more than one \li{except} statements corresponding to a single \li{try} statement, each indicating which exception class(es) to catch.
An \li{else} statement can also be attached after \li{except} statements, which is only executed if the \li{try} block is executed to completion.
\end{comment}

See \url{https://docs.python.org/2/tutorial/errors.html} for more examples.

% Catch a KeyboardInterrupt.
% This example is very simple; it could be expanded to a simple random walk.
\begin{problem}
A \li{KeyboardInterrupt} is a special exception that can be triggered at any time by entering \li{ctrl c} (on most systems) in the keyboard.
% Usually a \li{KeyboardInterrupt} is used to manually escape faulty code that runs forever, but it can also be used intentionally to truncate a process.

\begin{lstlisting}
from random import choice

def random_walk(max_iters=1e9):
    walk = 0
    direction = [1, -1]
    for i in xrange(max_iters):
        walk += choice(direction)
    return walk
\end{lstlisting}
Modify \li{random_walk()} so that if the user raises a \li{KeyboardInterrupt}, the function prints ``Process Interrupted at $x$\%'' (where $x$ is the percent completion through the loop).
If no \li{KeyboardInterrupt} is raised, print ``Process Completed''.
In both cases, return \li{walk} as before.
\end{problem}

% TODO: For Python 3, discuss chaining Exceptions.
\begin{comment}
\subsection*{Chaining Exceptions}
\begin{lstlisting}
>>> try:
>>>     raise ValueError("First Exception")
>>> except ValueError as e:
>>>     raise ZeroDivisionError("Second Exception") from e
\end{lstlisting}
\end{comment}

\subsection*{The Exception Hierarchy}

The built-in Python exceptions are organized into a class hierarchy.
This can lead to some confusing behavior if you aren't careful!

\begin{lstlisting}
>>> try:
...     raise ValueError("This is a ValueError!")
... except StandardError as e:
...     print e
...
<<This is a ValueError!>>                       # The exception was caught.

>>> try:
...     raise StandardError("This is a StandardError!")
... except ValueError as e:
...     print e
...
<<Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
StandardError: This is a StandardError!>>     # The exception wasn't caught!
\end{lstlisting}

It turns out that the \li{ValueError} class inherits from the \li{StandardError} class.
Thus a \li{ValueError} \emph{is} a \li{StandardError}, so the first \li{except} statement was able to catch the exception, but a \li{StandardError} is \emph{not} a \li{ValueError}, so the second \li{except} statement could not catch the exception.
The complete exception classes hierarchy is documented at \url{https://docs.python.org/2/library/exceptions.html#exception-hierarchy}.

\section*{File Input and Output} % ============================================

Python has a useful \li{file} object which acts as an interface to all kinds of different file streams.
The built-in function \li{open()} creates a \li{file} object.

\begin{lstlisting}
>>> myfile = open("in.txt", 'r')        # Open 'in.txt' with read-only access.
>>> for line in myfile:                 # Print out each line of the file.
...     print(line)
...
>>> myfile.close()                      # Close the file connection.
\end{lstlisting}

\li{open()} accepts up to three arguments: the filename, mode, and buffering options.
The mode determines the kind of access to use when opening the file.
\begin{description}
\item \li{'r'}: opens an existing file for read-only access.
This is the default mode.
\item \li{'w'}: opens a file for write-only access.
This mode creates the file if it doesn't already exist, and \textbf{\emph{overwrites everything}} in the file if it does exist.
\item \li{'a'}: opens a file for appending, meaning new data is written to the end of the file.
This mode also creates a new file if it doesn't already exist.
\end{description}

\subsection*{The With Statement} % --------------------------------------------

An \li{IOError} indicates that some input or output operation has failed.
If a file cannot be opened for any reason, an \li{IOError} is raised and the file object is not initialized.
A simple \li{try}-\li{finally} control flow can ensure that a file stream is closed safely.

The \li{with} statement provides an alternative method for safely opening and closing files.
Use \li{with open(<filename>, <mode>) as <alias>:} to create an indented block in which the file is open and available under the specified alias.
At the end of the block, the file is automatically closed.
This is the preferred file-reading method when a file only needs to be accessed briefly.
The more flexible \li{try}-\li{finally} approach is typically better for working with several file streams at once.

\begin{lstlisting}
>>> myfile = open("in.txt", 'r')        # Open 'in.txt' with read-only access.
>>> try:    
...     contents = myfile.readlines()   # Read in the content by line.
... finally:
...     myfile.close()                  # Explicitly close the file.

# Equivalently, use a 'with' statement to take care of errors.
>>> with open("in.txt", 'r') as myfile: # Open 'in.txt' with read-only access.
...    contents = myfile.readlines()    # Read in the content by line.
...                                     # The file is closed automatically.
\end{lstlisting}

In both cases, if the file \texttt{in.txt} does not exist in the current directory, an \li{IOError} will be raised.
However, errors in the \li{try} or \li{with} blocks will not prevent the file from being safely closed.

% =============================================================================
% Done to here ================================================================
% =============================================================================

\subsection*{Reading and Writing} % -------------------------------------------

\begin{table}[H]
\begin{tabular}{r|l}
Attribute & Description \\
\hline
\li{closed} & True if file object is closed. \\
\li{mode} & The access mode used to open the file object. \\
\li{name} & The name of the file. \\ \\
Method & Description\\
\hline
\li{close()} & Flush any delayed writes and close the file object. \\
\li{read()} & Read the next string of the file (probably the whole file). \\
\li{readline()} & Read a line of the file, including the newline character at the end.\\
\li{readlines()} & Read lines of the file until the end of file (returned as a list).\\
\li{write()} & Write a string to the file. \\
\li{writelines()} & Write a sequence of strings to the file (input a list). Note that \\
 & newline characters are not added automatically.\\
\end{tabular}
\caption{Important \li{file} object attributes and methods.}
\label{table:fileattribs}
\end{table}

Every file object has several attributes and methods.
Some of the most notable are described in Table \ref{table:fileattribs}.
Only strings can be written to files; to write a non-string type, first cast it as a string using the \li{str} function.

\begin{lstlisting}
>>> try:
...     outfile = open('out.txt', 'w') # Open 'out.txt' with write-only access.
...     for i in xrange(10):
...         outfile.write(str(i**2))        # Write some strings to the file.
... except IOError as e:
...     print "Problem writing to file:", e
... else:
...     outfile.close()                     # Explicitly close the file.

# The flow is much less cumbersome using a 'with' statement.
>>> with open('out.txt', 'w') as outfile:   # Open 'out.txt' using 'with'.
...     for i in xrange(10):                
...         outfile.write(str(i**2))        # Write some strings to the file.
...
>>> outfile.closed                          # The file is closed automatically.
True
\end{lstlisting}

% Problem 4: Start the ContentFilter class.
\begin{problem}
Write a \li{ContentFilter} class.
The constructor should accept the name of a file to be read.
Store the name of the file and its contents as class attributes.
Remember to securely close the file.

If the filename argument is not a string, raise a \li{TypeError}.
\end{problem}

\subsection*{String Formatting}

% \begin{table}
% \begin{tabular}{|l|l|}
%  \hline
% Method & Returns \\
% \hline
% \li{isalpha()} & True if all characters in the string are alphabetic. \\
% \li{isdigit()} & True if all characters in the string are digits. \\
% \li{isspace()} & True if all characters in the string are whitespace (\li{" "}, \li{\\t}, \li{\\n}, etc). \\
% \li{capitalize()} & A copy of the string with only its first character capitalized. \\
% \li{lower()} & A copy of the string converted to lowercase. \\
% \li{upper()} & A copy of the string converted to uppercase. \\
% \li{split()} & A list of segments of the string, using a given character or string \\
%  & as a delimiter. The default is to separate on whitespace. \\
% \li{strip()} & A copy of the string with leading and trailing whitespace removed. \\
% \hline
% \end{tabular}
% \caption{Some of the important \li{str} object methods.}
% \label{table:strmethods}
% \end{table}

%A few of the more useful methods are listed in Table \ref{table:strmethods}.
%Talk about the is stuff (\li{isalnum}/\li{isspace}), formatting (\li{capitalize}/\li{lower}/\li{swapcase}), and \li{split} and \li{strip}.


Python's \li{str} type class has several useful methods for formatting and arranging strings.
They are particularly useful for processing data from a source file.
As always, IPython's object introspection allows us to learn about these methods quickly.

\begin{lstlisting}
In [1]: str.    # Press 'tab'.
<<str.capitalize  str.isalnum     str.lstrip      str.splitlines
str.center      str.isalpha     str.partition   str.startswith
str.count       str.isdigit     str.replace     str.strip
str.decode      str.islower     str.rfind       str.swapcase
str.encode      str.isspace     str.rindex      str.title
str.endswith    str.istitle     str.rjust       str.translate
str.expandtabs  str.isupper     str.rpartition  str.upper
str.find        str.join        str.rsplit      str.zfill
str.format      str.ljust       str.rstrip      
str.index       str.lower       str.split>>

In [1]: str.upper?
Docstring:
S.upper() -> string

Return a copy of the string S converted to uppercase.
Type:      method_descriptor
\end{lstlisting}

% TODO: a little table of string methods.
Use IPython to learn about and get a feel for the following \li{str} methods: \li{isalpha()}, \li{isdigit()}, \li{isspace()}, \li{join()}, \li{lower()}, \li{replace()}, \li{split()}, \li{strip()}, and \li{upper()}.

Below, we demostrate the \li{join()} and \li{split()} methods.

\begin{lstlisting}
# str.join() puts the string between the entries of a list.
>>> words = ["state", "of", "the", "art"]
>>> "-".join(words)
'state-of-the-art'

# str.split() creates a list out of a string, given a delimiter.
>>> "One fish\nTwo fish\nRed fish\nBlue fish\n".split('\n')
['One fish', 'Two fish', 'Red fish', 'Blue fish', '']
\end{lstlisting}

% Problem 5: Add methods to the ContentFilter class.
\begin{problem}
Add the following methods to the \li{ContentFilter} class for writing the contents of the original file to new files.
Each method should accept a filename to write to and a keyword argument \li{mode} that specifies the file access mode, defaulting to \li{'w'}.
If \li{mode} is not either \li{'w'} or \li{'a'}, raise an \li{ValueError} with an informative message.

\begin{enumerate}

\item \li{hyphenate()}: write the data to the outfile in a single line, with \li{"-"} placed between each word and line.

\item \li{uniform()}: write the data to the outfile with uniform case. Include an additional keyword argument, \li{case}, that defaults to \li{'upper'}.

If \li{case='upper'}, write the data in upper case. If \li{case='lower'}, write the data in lower case. If \li{case} is not one of these two values, raise an \li{ValueError}.

\item \li{reverse()}: write the data to the outfile in reverse order. Include an additional keyword argument \li{unit} that defaults to \li{'line'}.

If \li{unit='word'}, reverse the ordering of the words in each line, but write the lines in the same order as the original file. If \li{unit='line'}, reverse the ordering of the lines, but do not change the ordering of the words on each individual line. If \li{unit} is not one of these two values, raise an \li{ValueError}.

\item \li{transpose()}: write a ``transposed'' version of the data to the outfile. That is, write the first word of each line of the data to the first line of the new file, the second word of each line of the data to the second line of the new file, and so on.
\end{enumerate}

Also implement the \li{__str__()} magic method so that printing a \li{ContentFilter} object yields the following output:
\begin{lstlisting}
<<Source file:              <filename>
Total characters:         <The total number of characters in the file>
Alphabetic characters:    <The number of letters>
Numerical characters:     <The number of digits>
Whitespace characters:    <The number of spaces, tabs, and newlines>
Number of lines:          <The number of lines>>>
\end{lstlisting}
\end{problem}

\newpage

% TODO: This stuff.
\section*{Additional Material} % ==============================================

\subsection*{Custom Exceptions}

Custom exceptions can be defined by writing a class that inherits from some existing exception class.
The generic \li{Exception} class is typically the parent class of choice.

\begin{lstlisting}
>>> class TooHardError(Exception):
...     pass
... 
>>> raise TooHardError("This lab is impossible!")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
__main__.TooHardError: This lab is impossible!
\end{lstlisting}

This class seems like a trivial extension of the \li{Exception} class, but it is useful because nothing automatically raises it.

\subsection*{Assertions} % ----------------------------------------------------

\begin{lstlisting}
>>> assert <statement>, <message>

# In other words...
>>> if not <statement>:
...     raise AssertionError(<message>)
\end{lstlisting}

Assertion errors are mostly for testing purposes and shouldn't be seen by a non-programmer.

\subsection*{The Finally Block} % ---------------------------------------------
% TODO: Put this section in the main content again. Maybe put 'else' here.
Another optional block after a \li{try} block with the header \li{finally}.
The code in a \li{finally} block executes after either the try or any subsequent block completes, regardless of whether or not an exception was actually raised.
It is \textbf{always} executed, even if there is another exception raised in the \li{except} block or if a value is returned!

\begin{lstlisting}
>>> def finally_test(param):
...     try:
...         raise ValueError(str(param))
...     except ValueError as e:
...         return str(e)
...     finally:
...         print "This is a test."
...
>>> finally_test("Yes it is.")
<<This is a test.
'Yes it is.'>>
\end{lstlisting}

\subsection*{Function Wrappers} % ---------------------------------------------

A \emph{function wrapper} or \emph{decorator} is a function that is meant to ``wrap'' another function by being called on top of the target function.
That is, if we have a function $f$, wrapped by function $g$, then whenever $f$ is called, we actually are calling $g(f(x))$.

For example, the following wrapper prints out the current time whenever the inner function is called.

\begin{lstlisting}
>>> from time import strftime

>>> def time_stamp(func):
...     def wrapper(*args, **kwargs):
...         try:
...             return func(*args, **kwargs)
...         finally:
...             print strftime("%H:%M:%S")
...     return wrapper
...
>>> @time_stamp
>>> def example():
...     return 10

>>> example()
10
16:27:17
\end{lstlisting}

Create a decorator that raises a \li{RuntimeError} after 10 seconds.
Consider using the \li{signal} module.\footnote{The \li{signal} module only works on unix machines (mac, linux).}
