\lab{Getting Started}{Getting Started}
\objective{Python is a powerful general-purpose programming language. As an interpreted language it can be used interactively, allowing for very rapid programming. Python also has many powerful scientific computing tools, making it an ideal language for data science and applied mathematics. In this introductory lab we introduce basic Python syntax, including data types, control flow blocks, and functions. We will explore Python's scientific computing packages in future labs.}
\label{lab:Essential_Python}

% FUTURE EDITS
%  - transition from ipython notebook to jupyter notebook
%  - transition from Python 2.7 to Python 3.x
%     - Use parenthesis with all print statements, as print is now a function.

% Introduction ================================================================

\section*{Python}
Python is quickly gaining momentum as a fundamental tool in scientific computing because it has the following features:
\begin{itemize}
\item Clear, readable syntax
\item Full object orientation
\item Complete memory management (via garbage collection)
\item High-level, dynamic datatypes
\item Extensibility via C
\item Ability to interface with other languages such as R, C, C++, and Fortran
\item Embeddability in applications
\item Portability across many platforms (Linux, Windows, Mac OSX)
\item Open source
\end{itemize}
In addition to these, Python is freely available and can also be freely distributed.

\subsection*{Installation}
% TODO: Update to Python 3
Python 2.7 is required for the labs in this text.
Anaconda is a free Python distribution that includes Python 2.7 and many of the commonly used libraries for scientific computing. 
Most of the libraries we will use in these labs are included in Anaconda.
We will add more libraries in the future as needed.

To download Anaconda, go to \url{http://continuum.io/downloads}, download the installer corresponding to your operating system, and follow the on-screen installation instructions. 
Make sure the installer you use corresponds to Python 2.7.
Although later versions of Python are available, they do not yet have many of the features needed for scientific computing. % TODO: Change this to Python 3
For more information on installing Python and various libraries, see Appendices \ref{pythoninstall} and \ref{updateinstall}.

\subsection*{Running Python}

Many free IDEs (Integrated Development Environments) and text editors are compatible with Python.
Some of the more popular text editors are described in Appendix A.
Try a variety of programming environments and configurations until you find what suits you best.
In addition, IPython provides an interactive interface with object introspection, and should be used side-by-side with a text editor or IDE.
We will discuss IPython in greater depth shortly.

A typical python file\footnote{Python files end with the extension .py.} looks similar to the code below.

\begin{lstlisting}
# filename.py
"""This is the file header.
The header contains basic information about the file.
"""

def main():
    """This is a docstring. It provides information about the function."""
    print("Hello, world!")

if __name__ == "__main__":
    main()
\end{lstlisting}

The \li{#} character creates a single-line comment.
Comments on the very first line can be used to give the interpreter special instructions, which we will discuss briefly in Volume III.
For now, we put the name of the file on the first line. 

A pair of three quotes \li{""" """} or \li{''' '''} creates a multi-line comment block.
A comment block at the top of the file serves as the header for the file.
The header typically includes the author, instructions on how to use the file, and so on.

Finally, the actual code is given below the header.
In this file, we have a single function called \li{main} that prints the string ``Hello, world!'' to the terminal.
Each statement under the \li{if __name__ == "__main__"} clause is executed when the file is run from the terminal.
Any code statements that are not within a function definition, but not under the \li{if __name__ == "__main__"} clause, will also be executed when the file is run from the terminal.
It is good coding practice to only write code within functions, then call those functions under the \li{if __name__ == "__main__"} clause.

% Problem 1: Run a file that prints "Hello, world!" to the terminal.
\begin{problem}
Create a new Python file and save it to your computer.
Write the filename and a brief header at the top, then add the following code at the end of the file:
\begin{lstlisting}
if __name__ == "__main__":
    print("Hello, world!")
\end{lstlisting}

Open a terminal (the command line) and navigate to the directory where the file is saved.
Use the \li{ls} command to list the files in the current directory, \li{pwd} to print the working directory, and \li{cd} to change directories.
Below, the \li{\$} character indicates that the command is being run from the terminal.

\begin{lstlisting}
$ pwd
/Users/Guest
$ ls
Desktop     Documents       Downloads       Pictures        Music
$ cd Documents
$ pwd
/Users/Guest/Documents
$ ls
getting_started.py
\end{lstlisting}

Now that we are in the same directory as the Python file, we can execute it using the following command:

\begin{lstlisting}
$ python getting_started.py
\end{lstlisting}

If ``Hello, world!'' is displayed in the terminal, you have just successfully executed your first Python program.
\label{prob:helloWorld}
\end{problem}

% IPython and Editors =========================================================

\subsection*{IPython}

Python can be run interactively using several interfaces.
The most basic of these is the Python interpreter.
In this and the following labs, the triple brackets \li{>>>} indicate that given code is being executed one line at a time via the Python interpreter.

\begin{lstlisting}
$ python                                # Start the Python interpreter.
>>> print("This is plain python.")      # Execute some code.
<<This is plain python.>>
\end{lstlisting}

There are, however, more useful interfaces.
Chief among these is IPython.
To execute a script in IPython, use the \li{run} command.

\begin{lstlisting}
>>> quit()                              # Exit the Python interpreter.
$ ipython                               # Start IPython.
In [1]: print("This is IPython!")       # Execute some code.
<<This is IPython!>>

In [2]: run getting_started.py          # Run a particular Python script.
Hello, world!
\end{lstlisting}

The advantage of IPython is that it supports \emph{object introspection}, whereas the regular Python interpreter does not.
Object introspection allows you to quickly see all methods and attributes associated with an object.
IPython also has a built-in \li{help} function that provides interactive help.

\begin{lstlisting}
# A list is a basic Python data structure. To see the methods associated with
# a list, type the object name (list), followed by a period, and press tab.
In [1]: list.   # Press 'tab'.
<<list.append   list.extend   list.insert   list.remove      list.sort
list.count    list.index    list.pop      list.reverse>>

# To learn more about a specific method, use "?".
In [2]: list.append?
<<Docstring:    L.append(object) -- append object to end
Type:         method_descriptor>>

In [3]: help()
<<help>>> list
<<Help on class list in module __builtin__:

class list(object)
 |  list() -> new empty list
 |  list(iterable) -> new list initialized from iterable's items
 |  ...>>
\end{lstlisting}

Use IPython side-by-side with a text editor or an IDE to test code snippets and syntax.
Testing code in IPython before putting it into your program helps you catch errors beforehand and greatly speeds up the debugging process.
If you cannot answer a coding question using these strategies, search the internet.
In particular, \href{http://stackoverflow.com/}{stackoverflow.com} is often a valuable resource for answering programming questions.

The Anaconda distribution also includes three additional interfaces: Notebook, QTConsole, and Spyder.
IPython Notebook (also know as Jupyter) is displayed in a web browser and has many features that are particularly useful for presentations and for running separated blocks of code.
The QTConsole is a console that communicates with Jupyter more fluidly than the regular IPython console.
Spyder is a popular IDE built specifically for Python programming.
To start IPython Notebook, QTConsole, or Spyder from the terminal, run \li{ipython notebook}, \li{ipython qtconsole}, or \li{spyder}, respectively.
Try using each of these interfaces until you find the one you are most comfortable with.

% Basics ======================================================================

\section*{Python Basics}

\subsection*{Arithmetic}
We can now dive into the particulars of Python syntax.
To begin, Python can be used as a calculator.
Use \li{**} for exponentiation.

\begin{lstlisting}
>>> 3**2 + 2*5                      # Python obeys the order of operations.
19

>>> 13 % 3                          # The modulo operator % calculates the
1                                   # remainder: 13 = (3*4) + 1. 
\end{lstlisting}
In most Python interpreters, the underscore character \li{\_} is a variable with the value of the previous command's output, like the ANS button on many calculators.

\begin{lstlisting}
>>> 12 * 3
36
>>> _ / 4
9
\end{lstlisting}

Data comparisons act as expected.
\begin{lstlisting}
>>> 3 > 2
True
>>> 4 < 4
False
>>> 1 <= 1
True
>>> 7 == 7
True
\end{lstlisting}

\subsection*{Variables}
Variables are used to temporarily store data.
A \emph{single} equals sign assigns one or more values (on the right) to one or more variable names (on the left).
A \emph{double} equals sign is a comparison operator, as in the previous code block.

Unlike many programming languages, Python does not require a variable's data type to be specified upon initialization.

\begin{lstlisting}
>>> x = 12                          # Initialize x with the integer 12.
>>> y = 2 * 6                       # Initialize y with the integer 2*6 = 12.
>>> x == y                          # Compare the two variable values.
True
>>> x, y = 2, 4                     # Give x and y new values in a single line.
>>> x == y
False
\end{lstlisting}

\subsection*{Functions}

To define a function, use the \li{def} keyword followed by the function name, a parenthesized list of formal parameters, and a colon.
Then indent the function body.
Many other languages use the curly braces \{ and \} to delimit blocks, but Python uses whitespace indentation.
This should be done using four spaces.
Most text editors will allow you to set the indentation type to spaces so you can use the tab key on your keyboard to insert four spaces.

\begin{lstlisting}
# No indentation leads to an error.
>>> def add(x, y):
...result = x + y
<<IndentationError: expected an indented block>>

# Instead, indent all lines that should be included in the function.
>>> def add(x, y):
...    result = x + y
...    return result
\end{lstlisting}

Functions are defined with \emph{parameters} and called with \emph{arguments}.
Below, \li{width} and \li{height} are parameters for the function \li{area}.
The values \li{2} and \li{5} are the arguments that are passed when calling the function.

In practice, the terms \emph{parameter} and \emph{argument} are often used interchangeably.

\begin{lstlisting}
>>> def area(width, height):
...     return width*height
...         
>>> area(2, 5)
10
\end{lstlisting}

It is also possible to specify default values for a function's formal parameters.
In the following example, the function \li{printer} has three formal parameters, and the value of \li{c} defaults to 0.
That is, if it is not specified in the function call, the variable \li{c} will contain the value 0 when the function is executed.

\begin{lstlisting}
>>> def printer(a, b, c=0):
...    print(a, b, c)
...
>>> printer(1, 2, 3)                # Specify each parameter.
1 2 3
>>> printer(1, 2)                   # Specify only non-default parameters.
1 2 0
\end{lstlisting} % TODO Python 3: give the print statement parentheses

Arguments are passed to functions based on position or name, and positional arguments must be defined before named arguments.
For example, \li{a} and \li{b} must come before \li{c} in the function definition of \li{printer}.

Carefully examine the following code block demonstrating how positional and named arguments are used to call a function.
\begin{lstlisting}
# Try defining printer with a named argument before a positional argument.
>>> def printer(c=0, a, b):
...    print(a, b, c)
...
SyntaxError: invalid syntax

# Correctly define printer with the named argument after positional arguments.
>>> def printer(a, b, c=0):
...    print(a, b, c)
...

# Call printer with 3 positional arguments.
>>> printer(2, 4, 6)
2 4 6

# Call printer with 3 named arguments. Note the change in order.
>>> printer(b=3, c=5, a=7)
7 3 5

# Call printer with 2 named arguments, excluding c.
>>> printer(b=1, a=2)
2 1 0

# Call printer with 1 positional argument and 2 named arguments.
>>> printer(1, c=2, b=3)
1 3 2
\end{lstlisting}

Finally, a Python function can return more than one value.
Simply separate the values by commas after the \li{return} statement.

\begin{lstlisting}
>>> def arithmetic(a, b):
...     difference = a - b
...     product = a * b
...     return difference, product
...
>>> x, y = arithmetic(5, 2)         # x is the difference, y is the product.
>>> print x, y
3 10
\end{lstlisting}

\begin{info}
The functions \li{area} and \li{printer} defined above have an important difference: \li{area} ends with a \li{return} statement, but \li{printer} lacks a \li{return} statement.

The \li{return} statement instantly ends the function call and passes the return value to the function caller.
The \li{print} statement does nothing more than display the value of a given object (or objects) in the terminal. % (see the following problem).
A function without a return statement implicitly returns the Python constant \li{None}.

\begin{lstlisting}
>>> x = area(2, 4)              # Executing area doesn't print anything,
>>> y = printer(1, 2, 3)        # but executing printer does.
1 2 3
>>> print(x)                    # However, x now contains a value,
8
>>> print(y)                    # whereas y only contains 'None'.
None
\end{lstlisting}

If you have any intention of using the results of a function, always use a \li{return} statement.
The returned value or values can then be stored in variables for later use.
\end{info}

\begin{comment}
% TODO: for Python 3, insert a problem introducting the user to the print function more formally. This problem should be simple, but it should explore the keyword arguments 'sep' and 'end' included in the print function.
\begin{problem}
Python's built-in \li{print} function is extremely useful for formatting output nicely.
Write a function that prints out the alphabet, separated by tabs, with newlines after every 5th letter. % SUBJECT TO CHANGE.
\end{problem}
\end{comment}

% Problem 2: write a very basic function.
\begin{problem}
In your Python file from Problem \ref{prob:helloWorld}, define a new function called \li{sphere_volume}.
This function should accept a single parameter \li{r} and return (not print) the volume of the sphere of radius \li{r}.
For now, approximate $\pi$ with $3.14159$.

To test your function, call it under the \li{if __name__ == "__main__"} clause and print the result.
Run your file to see if your answer is what you expect it to be.
\end{problem}

\section*{Data Types}

% Numerical Types -------------------------------------------------------------

\subsection*{Numerical Types}
Python has four numerical data types: \li{int}, \li{long}, 
\li{float}, and \li{complex}.
Each stores a different kind of number.
The built-in function \li{type} identifies an object's data type.

\begin{lstlisting}
>>> type(3)                         # Numbers without periods are integers.
<<int>>

>>> type(3.0)                       # Floats have periods (3. is also a float).
<<float>>
\end{lstlisting}

% TODO: Update this section for Python 3.
Python has two types of division: integer and float.
%The \li{/} operator performs float division (fractional division), and the \li{//} operator performs integer division.
%Integer division rounds the result down to the next integer.
Integer division rounds the the result down to the next integer, and float division perfoms true, fractional division.
Both are executed  with the \li{/} operator.
When one or both of the operands are non-integers, \li{/} performs float division.
If both operands are integers, integer division is performed.

% TODO: for Python 3, change all operands to ints and use // for the second one
\begin{lstlisting}
>>> 15.0 / 4.0                      # Float division performs as expected.
3.75
>>> 15 / 4                          # Integer division rounds the result to 3.
3
\end{lstlisting}

\begin{warn} % TODO: This warning can be deleted for Python 3.
Using integer division unintentionally when float division is needed instead is an incredibly common programming mistake.
To avoid this, cast at least one operand as a float before dividing.
\begin{lstlisting}
>>> x, y = 7, 5
>>> x / y
1
>>> float(x) / y
1.4
>>> x / float(y)
1.4
\end{lstlisting}
\end{warn}

Python also supports complex number computations.
Use the letter j, not i, for the imaginary part.
\begin{lstlisting}
>>> x = complex(2,3)                # Create a complex number this way...
>>> y = 4 + 5j	                    # ...or this way, using j (not i).
>>> x.real                          # Access the real part of x.
2
>>> y.imag                          # Access the imaginary part of y.
5
\end{lstlisting}

% Strings =====================================================================

\subsection*{Strings}
In Python, strings are created with either single or double quotes.
To concatenate two or more strings, use the \li{+} operator between string variables or literals.
\begin{lstlisting}
>>> str1 = "Hello"
>>> str2 = 'world'
>>> my_string = str1 + " " + str2 + "!"
>>> my_string
<<'Hello world!'>>
\end{lstlisting}

We can access parts of a string using \emph{slicing}, indicated by square brackets \li{[ ]}.
Slicing syntax is \li{[start:stop:step]}.
The parameters \li{start} and \li{stop} default to the beginning and end of the string, respectively.
The parameter \li{step} defaults to 1.

\begin{lstlisting}
>>> my_string = "Hello world!"
# Indexing begins at 0 and negative numbers count backward from the end.
>>> my_string[4]
<<'o'>>
>>> my_string[-1]
<<'!'>>

# Slice from the 0th to the 5th character (not including the 5th character).
>>> my_string[:5]
<<'Hello'>>

# Slice from the 6th character to the end.
>>> my_string[6:]
<<'world!'>>

# Slice from the 3rd to the 8th character (not including the 8th character).
>>> my_string[3:8]
<<'lo wo'>>

# Get every other character in the string.
>>> my_string[::2]
<<'Hlowrd'>>
\end{lstlisting}

% Problem 3: Slicing with strings
\begin{problem}
Write two new functions, called \li{first_half} and \li{backward}.
\begin{enumerate}
\item \li{first_half} should accept a parameter and return the first half of it, excluding the middle character if there is an odd number of characters.

(Hint: the built-in function \li{len} returns the length of the input.)
\item The \li{reverse} function should accept a parameter and reverse the order of its characters using slicing, then return the reversed string.

(Hint: The \li{step} parameter used in slicing can be negative.)
\end{enumerate}
Use IPython to quickly test your syntax for each function.
\end{problem}

% Lists =======================================================================

\subsection*{Lists}
A Python \li{list} is created by enclosing comma-separated values with square brackets \li{[ ]}.
Entries of a \li{list} do not have to be of the same type.
Access entries in a \li{list} with the same indexing or slicing operations used with strings.
\begin{lstlisting}
>>> my_list = ["Hello", 93.8, "world", 10]
>>> my_list
<<['Hello', 93.8, 'world!', 10]>>
>>> my_list[0]
<<'Hello'>>
>>> my_list[-2]
<<'world!'>>
>>> my_list[:2]
<<['Hello', 93.8]>>
\end{lstlisting}

Common methods of the \li{list} data type include \li{append}, \li{insert}, \li{remove}, and \li{pop}.
Consult IPython for details on each of these methods using object introspection.
\begin{lstlisting}
>>> my_list = [1, 2]
>>> my_list.append(4)
>>> my_list.insert(2, 3)
>>> my_list
[1, 2, 3, 4]
>>> my_list.remove(3)
>>> my_list.pop()
4
>>> my_list
[1, 2]
\end{lstlisting}

Slicing is also very useful for replacing values in a list.
\begin{lstlisting}
>>> my_list = [1, 2, 3, 4, 5]
>>> my_list[3:] = [9, 10]
[1, 2, 3, 9, 10]
\end{lstlisting}

The \li{in} operator quickly checks if a given value is in a list (or a string).
\begin{lstlisting}
>>> my_list = [1, 2, 3, 4, 5]
>>> 2 in my_list
True
>>> 6 in my_list
False
\end{lstlisting}

\subsection*{Tuples}
A Python \li{tuple} is an ordered collection of elements, created by enclosing comma-sparated values with parentheses \li{(} and \li{)}.
Tuples are similar to lists, but they are much more rigid, have less built-in operations, and cannot be altered after creation.
Lists are therefore preferable for managing dynamic ordered collections of objects.

When multiple objects are returned in by a function, they are returned as a \li{tuple}.
For example, recall that the \li{arithmetic} function returns two values.

\begin{lstlisting}
>>> x, y = arithmetic(5,2)                      # Get each value individually,
>>> print x, y
3 10
>>> both = arithmetic(5,2)                      # or get them both as a tuple.
>>> print(both)
(3, 10)
\end{lstlisting}

% Problem 4: List operations
\begin{problem}
Write a function called \li{list_ops}.
Accept a parameter (a list) and perform the following operations on it, in order.
Return the resulting list.
\begin{enumerate}
\item Append \li{"elephant"}.
\item Remove \li{"ant"}.
\item Remove the entry at index 1.
\item Replace the entry at index 2 with \li{"eagle"}.
\item Append \li{"fox"}.
\end{enumerate}
\end{problem}

% Sets ========================================================================

\subsection*{Sets}
A Python \li{set} is an unordered collection of distinct objects.
Objects can be added to or removed from a \li{set} after its creation.
Initialize a \li{set} with curly braces \li{\{ \}}, separating the values by commas, or use \li{set()} to create an empty set.
\begin{lstlisting}
# Initialize some sets. Note that repeats are not added.
>>> library_members = {"Lytle, Josh", "Henriksen, Amelia", "Webb, Jared"}
>>> gym_members = {"Doe, John", "Doe, John", "Smith, Jane", "Brown, Bob"}
>>> print(gym_members)
<<set(['Brown, Bob', 'Doe, John', 'Smith, Jane'])>>

# Delete an object from a set.
>>> gym_members.discard("Doe, John");
>>> print(gym_members)
<<set(['Brown, Bob', 'Smith, Jane'])>>

# Add an object to a set.
>>> gym_members.add("Lytle, Josh")
>>> print(gym_members)
<<set(['Brown, Bob', 'Lytle, Josh', 'Smith, Jane'])>>
\end{lstlisting}

Like mathematical sets, a Python \li{set} has operations like union, intersection, 
difference, and symmetric difference.
\begin{lstlisting}
# Set intersection returns a new set object.
>>> gym_members.intersection(library_members)
<<set(['Lytle, Josh'])>>
\end{lstlisting}

% Dictionaries ================================================================

\subsection*{Dictionaries}
Like a \li{set}, a Python \li{dict} (dictionary) is an unordered data type.
A \li{dict} stores \li{key:value} pairs, called \emph{items}.
The values of a dictionary are indexed by its keys.
Dictionaries are initialized with curly braces, colons, and commas.
Use \li{dict()} to create an empty dictionary.
\begin{lstlisting}
>>> my_dictionary = {"business": 4121, "math": 2061, "visual arts": 7321} 
>>> print(my_dictionary["math"])
2061

# Add a value indexed by 'science' and delete the 'business' keypair.
>>> my_dictionary["science"] = 6284
>>> my_dictionary.pop("business")       # Use 'pop' or 'popitem' to remove.
4121
>>> print(my_dictionary)
<<{'visual arts': 7321, 'math': 2016, 'science': 6284}>>

# Display the keys and values.
>>> my_dictionary.keys()
<<['visual arts', 'math', 'science']>>
>>> my_dictionary.values()
<<[7321, 2016, 6284]>>
\end{lstlisting}

The keys of a dictionary must be \emph{immutable}, which means that they must be objects that cannot be modified after creation.
We will discuss the mutablility of each of these objects in the next lab.

\subsection*{Type Casting}

The names of each of Python's data types can be used as functions to cast a value as that type.
This is particularly useful with integers and floats.
\begin{lstlisting}
# Cast numerical values as different kinds of numerical values.
>>> x = int(3.0)
>>> y = float(3)
>>> z = complex(3)
>>> print x, y, z
3, 3.0, (3+0j)

# Cast a list as a set and vice versa.
>>> a = set([1, 2, 3, 4, 4])
>>> b = list({'a', 'a', 'b', 'b', 'c'})
>>> print a
<<set([1, 2, 3, 4])>>
>>> print b
<<['a', 'b', 'c']>>

# Cast other objects as strings.
>>> s = str(['a', str(1), 'b', float(2)])
>>> t = str(list(set([complex(float(3))]))
>>> s
<<"['a', '1', 'b', 2.0]">>
>>> t
<<'[(3+0j)]'>>

\end{lstlisting}

% Control Flow Tools ==========================================================

\section*{Control Flow Tools}
Control flow blocks dictate the order in which code is executed.
Python supports the usual control flow statements including \li{if} statements, \li{while} loops and \li{for} loops.

\subsection*{The If Statement}
An \li{if} statement executes the indented code \emph{if} (and only if) the given condition holds.
The \li{elif} statement is short for ``else if'' and can be used multiple times following an \li{if} statement, or not at all. 
The \li{else} keyword may be used at most once at the end of a series of \li{if}/\li{elif} statements.
\begin{lstlisting}
>>> food = "bagel"         
>>> if food == "apple":             # As with functions, the colon denotes
...     print "72 calories"         # the start of each code block.
... elif food == "banana":
...     print "105 calories"
... else: 
...     print "calorie count unavailable"
...     
calorie count unavailable
\end{lstlisting}

% Problem 5: If statements and Pig Latin.
\begin{problem}
Write a function called \li{pig_latin}.
Accept a parameter \li{word}, translate it into Pig Latin, then return the translation.
Specificaly, if \li{word} starts with a vowel, add ``hay'' to the end; if \li{word} starts with a consonant, take the first character of \li{word}, move it to the end, and add ``ay''.

(Hint: use the \li{in} operator to check if the first letter is a vowel.)
\end{problem}

\subsection*{The While Loop}
A \li{while} loop executes an indented block of code \emph{while} the given condition holds. 

\begin{lstlisting}
>>> i = 0
>>> while i < 10:        
...     print(i),            
...     i = i+1
...     
0 1 2 3 4 5 6 7 8 9
\end{lstlisting}

There are two additional useful statements to use in loops:
\begin{enumerate}
\item The \li{break} statement manually exits the loop, regardless of which iteration the loop is on or if the termination condition is met.
\item The \li{continue} statement skips the current iteration and returns to the top of the loop block if the termination condition is still not met.
\end{enumerate}

\begin{lstlisting}
>>> i = 0
>>> while True:
...    print(i),
...    i += 1
...    if i >= 10:
...        break        # Exit the loop.
...
0 1 2 3 4 5 6 7 8 9

>>> i = 0
>>> while i < 10:
...     i += 1
...     if i % 3 == 0:
...         continue    # Skip multiples of 3.
...     print(i),
1 2 4 5 7 8 10

\end{lstlisting}

\subsection*{The For Loop}
A \li{for} loop iterates over the items in any \emph{iterable}.
Iterables include (but are not limited to) lists, sets, and dictionaries.
There are a few different ways to define a \li{for} loop, with the most common ways demonstrated below.

\begin{lstlisting}
>>> for i in range(10):
...    print(i),
...     
0 1 2 3 4 5 6 7 8 9

>>> for i in range(50,100,10):
...    print(i),
...
50 60 70 80 90

# When the iterable is a list and the indices are unimportant,
# we can use this intuitive and useful syntax.
>>> my_list = ["red", "green", "blue", "yellow"]
>>> for entry in my_list:
...    print(entry),
...
red green blue yellow

# When keeping track of indices is important, use this method.
>>> for i in range(len(my_list)):
...    print(my_list[i] + str(i)),
...
red0 green1 blue2 yellow3
\end{lstlisting}

The \li{break} and \li{continue} statements also work in \li{for} loops, but a \li{continue} in a \li{for} loop will automatically increment the index or item, whereas a \li{continue} in a \li{while} loop makes no automatic changes to any variable.

% Problem 6: int_to_string using Dictionaries and a For loop
\begin{problem}
Write a function called \li{int_to_string}.
Accept a list \li{my_list} of integers, each between 1-26, to the corresponding lower-case letter of the alphabet.
The number 1 becomes `a', 2 becomes `b', and so on.

(Hint: consider using a dictionary and a loop)
\end{problem}

% List Comprehension ==========================================================

\subsection*{List Comprehension}
A \emph{list comprehension} uses a loop between square brackets to create a \li{list}.
This is a powerful, efficient way to build lists.
The code is concise and runs quickly.

\begin{lstlisting}
>>> [float(n) for n in range(5)]
[0.0, 1.0, 2.0, 3.0, 4.0]
\end{lstlisting}

The following \li{for} loop and list comprehension produce the same list but the list comprehension takes about two-thirds the time to execute.

\begin{lstlisting}
>>> loop_output = []
>>> for i in range(5):
...    loop_output.append(i**2)
...
>>> list_output = [i**2 for i in range(5)]
\end{lstlisting}

% Problem 7: stringify
\begin{problem}
Write a function called \li{stringify}.
Accept a list \li{my_list} of numbers and convert each entry of the list into a string using list comprehension.
Return the new list.
\end{problem}

% Problem 8: the alternating harmonic series.
\begin{problem}
Write a function called \li{alt_harmonic}.
The alternating harmonic series (1 - 1/2 + 1/3 - 1/4 + 1/5 - ...) converges to ln(2).
Use a list comprehension to compute the first \li{n} terms of this series, given the parameter \li{n}.
The sum of the first 500,000 terms of this series approximates ln(2) to five decimal places.

(Hint: consider using Python's built-in \li{sum} function.)
\end{problem}

\section*{Conclusion}
Refer back to this and other introductory labs often as you continue getting used to Python syntax and data types.
As you continue your study of Python, we strongly recommend the following readings:
\begin{enumerate}
\item Chapters 3, 4, and 5 of the Official Python Tutorial \\
        (\url{http://docs.python.org/2.7/tutorial/introduction.html}).
\item Section 1.2 of the SciPy Lecture Notes\\
        (\url{http://scipy-lectures.github.io/}).
\item PEP8 - Python Style Guide \\
        (\url{http://www.python.org/dev/peps/pep-0008/}).
\end{enumerate}
